<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SolusKey Verification</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
    body { background: radial-gradient(circle,#0f2027,#203a43,#2c5364); display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; color: #fff; }
    h1 { font-size: 2.8em; margin-bottom: .2em; }
    h2 { font-size: 1.4em; margin-bottom: .8em; }
    #wrap { background: rgba(255,255,255,0.04); padding: 25px; border-radius: 18px; box-shadow: 0 0 12px rgba(0,0,0,0.7); width: 380px; }
    #screen { display: flex; align-items: center; justify-content: center; height: 65px; font-size: 2.2em; letter-spacing: 8px; background: rgba(255,255,255,0.1); border-radius: 14px; margin-bottom: 15px; transition: .2s; }
    #pad { display: grid; grid-template-columns: repeat(3,1fr); gap: 14px; margin-bottom: 20px; }
    .btn { padding: 22px; font-size: 1.7em; background: linear-gradient(145deg,#2e8b57,#3cb371); color: #fff; border: none; border-radius: 14px; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.5); transition: transform .15s, background .3s; }
    .btn:hover { transform: scale(1.07); background: linear-gradient(145deg,#3cb371,#4caf50); }
    .btn:active { transform: scale(0.95); }
    #code { text-align: center; font-size: 2em; background: rgba(255,255,255,0.1); padding: 12px; border-radius: 14px; margin-top: 10px; }
    #shimmer { width: 100%; height: 7px; margin-top: 10px; background: linear-gradient(to right,transparent,#fff,transparent); animation: shimmer 2.4s infinite; }
    @keyframes shimmer { 0%{transform:translateX(-100%);}50%{transform:translateX(0%);}100%{transform:translateX(100%);} }
    #error { font-size: 1.2em; margin-top: 10px; color: #f66; display: none; text-align: center; }
    #info { text-align: center; font-size: .95em; opacity: .7; margin-top: 10px; }
    #logo { font-size: 3em; margin-bottom: 12px; text-shadow: 0 0 15px #3cb371; }
    #cover { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 99; display: none; align-items: center; justify-content: center; }
    #cover span { font-size: 2.2em; color: #fff; }
  </style>
</head>
<body>
  <h1 id="logo">üîê</h1>
  <h2>Enter PIN</h2>

  <div id="wrap">
    <div id="screen">‚Ä¢‚Ä¢‚Ä¢‚Ä¢</div>
    <div id="pad"></div>
    <div id="code">Code: ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</div>
    <div id="shimmer"></div>
    <div id="error">Invalid Access</div>
    <div id="info">Device synced. Updates every 30s.</div>
  </div>

  <div id="cover"><span>Locked</span></div>

  <script>
  (function(){
    // UI elements
    const screen  = document.getElementById('screen');
    const pad     = document.getElementById('pad');
    const codeEl  = document.getElementById('code');
    const errorEl = document.getElementById('error');
    const cover   = document.getElementById('cover');
    const buttons = ['1','2','3','4','5','6','7','8','9','C','0','‚Ü©'];

    let pin   = '';
    let fails = 0;
    const LOCK_KEY = 'lockedUntil';

    // Show/hide lock screen
    function showCover(){ cover.style.display = 'flex'; }
    function hideCover(){ cover.style.display = 'none'; }

    // Persist lockout across refresh
    const now = Date.now();
    const lockedUntil = parseInt(localStorage.getItem(LOCK_KEY) || '0', 10);
    if (lockedUntil > now) {
      showCover();
      setTimeout(() => {
        hideCover();
        localStorage.removeItem(LOCK_KEY);
        fails = 0;
      }, lockedUntil - now);
    }

    // Render keypad
    buttons.forEach(ch => {
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.textContent = ch;
      btn.onclick = () => handleInput(ch);
      pad.appendChild(btn);
    });

    // Update PIN display
    function updateScreen(){
      screen.textContent = pin.padEnd(4, '‚Ä¢');
    }
    updateScreen();

    // Handle button presses
    function handleInput(ch){
      if (cover.style.display === 'flex') return;

      if (ch === 'C') {
        pin = '';
      } else if (ch === '‚Ü©') {
        if (pin.length === 4) {
          verifyPin();
        } else {
          fails++;
          if (fails > 2) applyLockout(60000);
        }
      } else {
        if (pin.length < 4) pin += ch;
      }

      updateScreen();
    }

    // Lockout logic
    function applyLockout(ms){
      const until = Date.now() + ms;
      localStorage.setItem(LOCK_KEY, until);
      showCover();
      setTimeout(() => {
        hideCover();
        localStorage.removeItem(LOCK_KEY);
        fails = 0;
      }, ms);
    }

    // Convert PIN to 16-char secret
    function secretFromPin(p){
      return p
        .padStart(16, 'X')
        .split('')
        .map(c => String.fromCharCode(((c.charCodeAt(0)*7) % 26) + 65))
        .join('');
    }

    // HMAC-SHA1 based HOTP
    async function generateHOTP(secret, counter){
      const keyData = new TextEncoder().encode(secret);
      const cryptoKey = await crypto.subtle.importKey(
        'raw', keyData, { name:'HMAC', hash:'SHA-1' }, false, ['sign']
      );
      const buf = new ArrayBuffer(8);
      new DataView(buf).setBigUint64(0, BigInt(counter));
      const sig = await crypto.subtle.sign('HMAC', cryptoKey, buf);
      const bytes = new Uint8Array(sig);
      const offset = bytes[bytes.length - 1] & 0xf;
      const bin = ((bytes[offset] & 0x7f) << 24) |
                  (bytes[offset+1] << 16) |
                  (bytes[offset+2] << 8) |
                  (bytes[offset+3]);
      return (bin % 1000000).toString().padStart(6, '0');
    }

    // TOTP = HOTP with time-based counter
    async function generateTOTP(secret){
      const counter = Math.floor(Date.now() / 30000);
      return await generateHOTP(secret, counter);
    }

    // Verify PIN, generate code
    async function verifyPin(){
      const secret = secretFromPin(pin);
      try {
        const totp = await generateTOTP(secret);
        codeEl.textContent = 'Code: ' + totp;
        errorEl.style.display = 'none';
      } catch (err) {
        errorEl.textContent = 'Error generating code';
        errorEl.style.display = 'block';
      } finally {
        pin = '';
        updateScreen();
      }
    }

    // Auto-refresh code every 30 seconds when PIN filled
    setInterval(() => {
      if (pin.length === 4) verifyPin();
    }, 30000);

  })();
  </script>
</body>
</html>
